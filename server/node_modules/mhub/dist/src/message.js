"use strict";
/**
 * MHub Message class.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Message to be sent or received over MHub network.
 */
class Message {
    /**
     * Construct message object.
     *
     * Note: headers are cloned, but data is NOT cloned, so don't change data after you've
     * passed it to the pubsub framework!
     */
    constructor(topic, data, headers) {
        this.topic = topic;
        this.data = data;
        this.headers = Object.assign({}, headers); // clone
    }
    /**
     * Create a Message object from a plain object, by taking its topic, data and
     * headers properties.
     *
     * Note that the data is not deep-cloned.
     *
     * @param o Input object. Must at least contain a `.topic` property.
     * @return New `Message` instance, with given topic, same data, and clone of headers.
     */
    static fromObject(o) {
        if (!o || typeof o !== "object") {
            throw new TypeError(`cannot create message from object, got ${typeof o}`);
        }
        return new Message(o.topic, o.data, o.headers);
    }
    /**
     * Perform a shallow clone of the message.
     *
     * I.e. the new message will share the same `data` as the source message,
     * so be careful when the data is an object: making changes to it will be
     * reflected in the old and new message.
     *
     * The headers (if any) are cloned into a new headers object.
     *
     * @return New message with same topic, same data and shallow clone of headers.
     */
    clone() {
        return new Message(this.topic, this.data, this.headers);
    }
    /**
     * Validate correctness of message properties, e.g. that topic is a string,
     * and header is either undefined or key-values.
     */
    validate() {
        if (typeof this.topic !== "string") {
            throw new TypeError(`invalid topic: expected string, got ${typeof this.topic}`);
        }
        const headers = this.headers;
        if (headers !== undefined && typeof headers !== "object") {
            throw new TypeError(`invalid headers: expected object or undefined, got ${typeof headers}`);
        }
        for (const key in headers) {
            if (!headers.hasOwnProperty(key)) {
                continue;
            }
            const t = typeof headers[key];
            if (t !== "string" && t !== "boolean" && t !== "number") {
                throw new TypeError(`invalid headers: expected string, boolean or number for header '${key}', got ${t}`);
            }
        }
    }
}
exports.Message = Message;
exports.default = Message;
//# sourceMappingURL=message.js.map
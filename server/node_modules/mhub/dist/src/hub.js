"use strict";
/**
 * Central container of Nodes, with possibility to have clients connect to it.
 * One Hub can be re-used by many different endpoint protocols (such as
 * WebSocket servers, raw TCP ports, etc.)
 *
 * A HubClient can be used to (internally) connect to a Hub, and is in
 * turn used by e.g. TcpConnection, WSConnection, and LocalClient.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const dict_1 = require("./dict");
const match_1 = require("./match");
const pubsub = require("./pubsub");
exports.defaultDenyPermissions = {
    publish: false,
    subscribe: false,
};
exports.defaultAllowPermissions = {
    publish: true,
    subscribe: true,
};
exports.defaultPermissions = exports.defaultDenyPermissions;
class Authorizer {
    constructor(partialPermissions) {
        // tslint:disable-next-line:no-null-keyword
        this._publishMatchers = Object.create(null);
        if (typeof partialPermissions === "boolean") {
            partialPermissions = partialPermissions ? exports.defaultAllowPermissions : exports.defaultDenyPermissions;
        }
        this._permissions = Object.assign(Object.assign({}, exports.defaultPermissions), partialPermissions);
    }
    canPublish(node, topic) {
        // Note: Matcher doesn't occur for publish, because the topic is never considered pattern
        return this._hasPermission(this._permissions.publish, node, topic, false) === true;
    }
    canSubscribe(node, pattern) {
        return this._hasPermission(this._permissions.subscribe, node, pattern, true);
    }
    _hasPermission(permission, node, topicOrPattern, isPattern) {
        if (typeof permission === "boolean") {
            return permission;
        }
        // Otherwise, must be a node->(boolean | string | string[]) map
        const nodePermission = permission[node];
        if (nodePermission === undefined) {
            return false;
        }
        if (typeof nodePermission === "boolean") {
            return nodePermission;
        }
        if (isPattern) {
            // If pattern is specified as-is, we grant access completely, no further
            // filtering necessary. If pattern isn't found, we assume the two patterns
            // (subscription and permissions) may intersect, but further checking will
            // be necessary.
            if (typeof nodePermission === "string") {
                if (nodePermission === topicOrPattern) {
                    return true;
                }
                return match_1.getMatcher(nodePermission);
            }
            const patternFoundInPermissions = nodePermission.some((pattern) => pattern === topicOrPattern);
            if (patternFoundInPermissions) {
                return true;
            }
            else {
                return match_1.getMatcher(nodePermission);
            }
        }
        else { // topicOrPattern is a topic
            let matcher = this._publishMatchers[node];
            if (!matcher) {
                this._publishMatchers[node] = match_1.getMatcher(nodePermission);
                matcher = this._publishMatchers[node];
            }
            return (topicOrPattern !== undefined) && matcher(topicOrPattern);
        }
    }
}
exports.Authorizer = Authorizer;
class Hub {
    constructor(authenticator) {
        this._nodes = new dict_1.default();
        this._rights = new dict_1.default();
        this._authenticator = authenticator;
    }
    setRights(rights) {
        validateUserRights(rights);
        this._rights.clear();
        Object.keys(rights).forEach((user) => {
            this._rights.set(user, rights[user]);
        });
    }
    getAuthorizer(username) {
        const partialPermissions = this._rights.get(username);
        return new Authorizer(partialPermissions);
    }
    init() {
        const initPromises = [];
        this._nodes.forEach((node) => {
            if (node.init) {
                initPromises.push(node.init(this));
            }
        });
        return Promise.all(initPromises).then(() => undefined);
    }
    setStorage(storage) {
        this._storage = storage;
    }
    getStorage() {
        // TODO: allowing caller to pass in storage sub-type is unsafe, but don't
        // now of a generic but better way to fix that right now. Note that the
        // storage users currently do check for the validity of the actual stored
        // data, so it's fine in practice.
        return this._storage;
    }
    add(node) {
        if (this.find(node.name)) {
            throw new Error("duplicate node: " + node.name);
        }
        this._nodes.set(node.name, node);
    }
    find(nodeName) {
        return this._nodes.get(nodeName);
    }
    findSource(nodeName) {
        const n = this.find(nodeName);
        return pubsub.isSource(n) ? n : undefined;
    }
    findDestination(nodeName) {
        const n = this.find(nodeName);
        return pubsub.isDestination(n) ? n : undefined;
    }
    authenticate(username, password) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._authenticator.authenticate(username, password);
        });
    }
}
exports.Hub = Hub;
/**
 * Test validity of structure of UserRights.
 * Throws an error if it's incorrect.
 */
function validateUserRights(rights) {
    if (typeof rights !== "object") {
        throw new TypeError("invalid UserRights: object expected");
    }
    const users = Object.keys(rights);
    for (const user of users) {
        // Obtain Permissions object per user
        const perms = rights[user];
        if (typeof perms === "boolean") {
            continue;
        }
        if (typeof perms !== "object") {
            throw new TypeError(`invalid UserRights: object or boolean expected for user "${user}"`);
        }
        // Check each Permission
        for (const action in perms) { // publish/subscribe
            if (!perms.hasOwnProperty(action)) {
                continue;
            }
            const perm = perms[action];
            if (typeof perm === "boolean") {
                continue;
            }
            if (typeof perm !== "object") {
                throw new TypeError(`invalid UserRights: object or boolean expected for user "${user}", action "${action}"`);
            }
            // It's a node->bool|string|string[] map
            for (const node in perm) {
                if (!perm.hasOwnProperty(node)) {
                    continue;
                }
                const nodePerm = perm[node];
                if (typeof nodePerm === "boolean") {
                    continue;
                }
                if (typeof nodePerm === "string") {
                    continue;
                }
                if (!Array.isArray(nodePerm)) {
                    throw new TypeError(`invalid UserRights: boolean, string or array of strings expected for user ` +
                        `"${user}", action "${action}", node "${node}"`);
                }
                const allStrings = nodePerm.every((x) => typeof x === "string");
                if (!allStrings) {
                    throw new TypeError(`invalid UserRights: boolean, string or array of strings expected for user ` +
                        `"${user}", action "${action}", node "${node}"`);
                }
            }
        }
    }
}
exports.validateUserRights = validateUserRights;
exports.default = Hub;
//# sourceMappingURL=hub.js.map
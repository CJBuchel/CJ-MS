"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const match_1 = require("../match");
const message_1 = require("../message");
const pubsub = require("../pubsub");
const log_1 = require("../log");
const QUEUE_STORAGE_ID = "QueueStorage";
const QUEUE_STORAGE_VERSION = 1;
class Queue extends pubsub.BaseSource {
    constructor(name, options) {
        super(name);
        this._queue = [];
        this.name = name;
        this.capacity = options && options.capacity || 10;
        this._matcher = match_1.getMatcher(options && options.pattern);
        this._options = options || {};
    }
    init(hub) {
        if (this._options.persistent) {
            this._storage = hub.getStorage();
        }
        if (!this._storage) {
            return Promise.resolve(undefined);
        }
        return this._storage.load(this.name).then((data) => {
            if (!data || typeof data !== "object") {
                return;
            }
            if (data.type !== QUEUE_STORAGE_ID || data.version !== QUEUE_STORAGE_VERSION) {
                log_1.default.warning(`Warning: discarding invalid storage ID / version for node '${this.name}'`);
                return;
            }
            for (const msg of data.queue) {
                this._queue.push(message_1.default.fromObject(msg));
            }
        });
    }
    send(message) {
        // Forward the message to all subscribers
        log_1.default.push("-> %s", this.name, message.topic);
        this._broadcast(message);
        log_1.default.pop();
        // Store this message if it matches the pattern
        if (this._matcher(message.topic)) {
            this._queue.push(message);
            while (this._queue.length > this.capacity) {
                this._queue.shift();
            }
            if (this._storage) {
                this._storage.save(this.name, {
                    type: QUEUE_STORAGE_ID,
                    version: QUEUE_STORAGE_VERSION,
                    queue: this._queue,
                }).catch((err) => {
                    log_1.default.error(`Error saving topic data in node '${this.name}': ${err}`);
                    // TODO replace with a more appropriate mechanism
                    process.exit(1);
                });
            }
        }
    }
    bind(destination, pattern) {
        super.bind(destination, pattern);
        const matcher = match_1.getMatcher(pattern);
        this._queue.forEach((msg) => {
            if (matcher(msg.topic)) {
                destination.send(msg);
            }
        });
    }
}
exports.Queue = Queue;
exports.default = Queue;
//# sourceMappingURL=queue.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const match_1 = require("../match");
const message_1 = require("../message");
const pubsub = require("../pubsub");
const log_1 = require("../log");
const TOPIC_STORE_STORAGE_ID = "TopicStoreStorage";
const TOPIC_STORE_STORAGE_VERSION = 1;
/**
 * Remember last message for each topic.
 *
 * A new message with the same topic will overwrite the last message with that
 * topic, unless the `data` part of the message is `undefined`, in which case
 * the message is deleted from memory.
 *
 * When a new Destination binds to this, all currently remembered topics are
 * sent to it.
 */
class TopicStore extends pubsub.BaseSource {
    constructor(name, options) {
        super(name);
        // tslint:disable-next-line:no-null-keyword
        this._state = Object.create(null);
        this.name = name;
        this._matcher = match_1.getMatcher(options && options.pattern);
        this._options = options || {};
    }
    init(hub) {
        if (this._options.persistent) {
            this._storage = hub.getStorage();
        }
        if (!this._storage) {
            return Promise.resolve(undefined);
        }
        return this._storage.load(this.name).then((data) => {
            if (!data || typeof data !== "object") {
                return;
            }
            if ((data.type !== TOPIC_STORE_STORAGE_ID && data.type !== "TopicStateStorage") ||
                data.version !== TOPIC_STORE_STORAGE_VERSION) {
                log_1.default.warning(`Warning: discarding invalid storage ID / version for node '${this.name}'`);
                return;
            }
            // tslint:disable-next-line:forin
            for (const topic in data.state) {
                this._state[topic] = message_1.default.fromObject(data.state[topic]);
            }
        });
    }
    send(message) {
        // Forward the message to all subscribers
        log_1.default.push("-> %s", this.name, message.topic);
        this._broadcast(message);
        log_1.default.pop();
        // Store or delete this message if it matches the pattern
        const topic = message.topic;
        if (this._matcher(topic)) {
            // First delete, then insert to maintain message order
            delete this._state[topic];
            if (message.data !== undefined) {
                this._state[topic] = message;
            }
            if (this._storage) {
                this._storage.save(this.name, {
                    type: TOPIC_STORE_STORAGE_ID,
                    version: TOPIC_STORE_STORAGE_VERSION,
                    state: this._state,
                }).catch((err) => {
                    log_1.default.error(`Error saving topic data in node '${this.name}': ${err}`);
                    // TODO replace with a more appropriate mechanism
                    process.exit(1);
                });
            }
        }
    }
    bind(destination, pattern) {
        super.bind(destination, pattern);
        const matcher = match_1.getMatcher(pattern);
        // tslint:disable-next-line:forin
        for (const topic in this._state) {
            if (matcher(topic)) {
                destination.send(this._state[topic]);
            }
        }
    }
}
exports.TopicStore = TopicStore;
exports.default = TopicStore;
//# sourceMappingURL=topicStore.js.map
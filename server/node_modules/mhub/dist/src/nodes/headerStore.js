"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const log_1 = require("../log");
const match_1 = require("../match");
const message_1 = require("../message");
const pubsub = require("../pubsub");
const HEADER_STORE_STORAGE_ID = "HeaderStoreStorage";
const HEADER_STORE_STORAGE_VERSION = 1;
const DEFAULT_OPTIONS = {
    persistent: true,
};
const MESSAGE_HEADER_NAME = "keep";
/**
 * Selectively remember messages (per topic) based on the presence of certain
 * message headers.
 *
 * Behavior is determined by the `keep` header:
 * { keep: true } -> Store message, replacing previous message with same topic if any
 * { keep: false } -> Remove any stored message for this topic (and pass this one on)
 * { } -> Just pass message on, without impacting any stored message for this topic
 *
 * When a new Destination binds to this, all currently remembered topics are
 * sent to it.
 */
class HeaderStore extends pubsub.BaseSource {
    constructor(name, options) {
        super(name);
        // tslint:disable-next-line:no-null-keyword
        this._state = Object.create(null);
        this.name = name;
        options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        this._options = options;
    }
    init(hub) {
        if (this._options.persistent) {
            this._storage = hub.getStorage();
        }
        if (!this._storage) {
            return Promise.resolve(undefined);
        }
        return this._storage.load(this.name).then((data) => {
            if (!data || typeof data !== "object") {
                return;
            }
            if (data.type !== HEADER_STORE_STORAGE_ID || data.version !== HEADER_STORE_STORAGE_VERSION) {
                log_1.default.warning(`Warning: discarding invalid storage ID / version for node '${this.name}'`);
                return;
            }
            // tslint:disable-next-line:forin
            for (const topic in data.state) {
                this._state[topic] = message_1.default.fromObject(data.state[topic]);
            }
        });
    }
    send(message) {
        log_1.default.push("-> %s", this.name, message.topic);
        const topic = message.topic;
        const keep = message.headers[MESSAGE_HEADER_NAME];
        if (keep !== undefined) {
            // First delete, then insert to maintain message order
            delete this._state[topic];
            if (keep) {
                this._state[topic] = message;
            }
            if (this._storage) {
                this._storage.save(this.name, {
                    type: HEADER_STORE_STORAGE_ID,
                    version: HEADER_STORE_STORAGE_VERSION,
                    state: this._state,
                }).catch((err) => {
                    log_1.default.error(`Error saving topic data in node '${this.name}': ${err}`);
                    // TODO replace with a more appropriate mechanism
                    process.exit(1);
                });
            }
        }
        // Forward the message to all subscribers
        this._broadcast(message);
        log_1.default.pop();
    }
    bind(destination, pattern) {
        super.bind(destination, pattern);
        const matcher = match_1.getMatcher(pattern);
        // tslint:disable-next-line:forin
        for (const topic in this._state) {
            if (matcher(topic)) {
                destination.send(this._state[topic]);
            }
        }
    }
}
exports.HeaderStore = HeaderStore;
exports.default = HeaderStore;
//# sourceMappingURL=headerStore.js.map
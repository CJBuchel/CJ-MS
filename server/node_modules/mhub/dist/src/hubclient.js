"use strict";
/**
 * Connect an external client / transport through the MHub protocol to the
 * internal Hub.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events = require("events");
const log_1 = require("./log");
const dict_1 = require("./dict");
const match_1 = require("./match");
const message_1 = require("./message");
const protocol = require("./protocol");
const pubsub = require("./pubsub");
class SubscriptionNode {
    constructor(conn, id, onResponse) {
        this._bindings = new dict_1.default();
        this.name = conn.name + "_" + id;
        this._id = id;
        this._onResponse = onResponse;
    }
    send(message) {
        log_1.default.debug("-> %s", this.name, message.topic);
        const response = {
            type: "message",
            topic: message.topic,
            data: message.data,
            headers: message.headers,
            subscription: this._id,
        };
        this._onResponse(response);
    }
    subscribe(node, pattern, matcher) {
        let bindings = this._bindings.get(node.name);
        if (!bindings) {
            bindings = {
                node,
                patterns: new dict_1.default(),
            };
            this._bindings.set(node.name, bindings);
        }
        pattern = pattern || "";
        // Only bind if not already bound using this exact pattern
        if (!bindings.patterns.get(pattern)) {
            bindings.patterns.set(pattern, matcher);
            node.bind(this, matcher);
        }
    }
    unsubscribe(node, pattern) {
        const bindings = this._bindings.get(node.name);
        if (!bindings) {
            return;
        }
        pattern = pattern || "";
        const matcher = bindings.patterns.get(pattern);
        if (!matcher) {
            return;
        }
        bindings.patterns.remove(pattern);
        node.unbind(this, matcher);
    }
    destroy() {
        this._bindings.forEach((binding) => {
            binding.node.unbind(this);
        });
        this._bindings.clear();
    }
}
/**
 * Link of one client to the hub.
 * Every transport (tcp, websocket, etc.) and the LocalClient use this to
 * connect to the hub, passing it raw JSON objects received over the wire
 * to `processCommand()` and receiving responses from it by listing to
 * the `response` event.
 *
 * Events emitted from HubClient:
 * @event response(data: protocol.Response) Emitted whenever a response to
 *        a command, or new data to a subscription, is sent to this client.
 */
class HubClient extends events.EventEmitter {
    constructor(hub, name) {
        super();
        this._subscriptions = new dict_1.default();
        this._onResponseHandler = (response) => {
            this.emit("response", response);
        };
        this._hub = hub;
        this.name = name;
        this._authorizer = this._hub.getAuthorizer(""); // permissions for anonymous user
    }
    /**
     * Disconnect from Hub.
     */
    close() {
        this._subscriptions.forEach((subscription) => subscription.destroy());
        this._subscriptions.clear();
    }
    /**
     * Set username.
     * The MHub protocol provides a login command, which can be used
     * to allow authentication across transports that otherwise don't
     * natively support it (e.g. raw tcp).
     * Some transports may deduce the authentication user using other
     * means (e.g. in SSL client certificate).
     *
     * Note: using this will make a subsequent login command fail.
     *
     * @param username Username to assume.
     */
    setUsername(username) {
        this._username = username;
        this._authorizer = this._hub.getAuthorizer(this._username);
    }
    /**
     * Validate and execute command against hub (e.g. login, publish,
     * subscribe, etc.).
     * Any response to the command (including errors) will be
     * passed back using the `response` event.
     *
     * @param msg Command to process.
     */
    processCommand(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            try {
                if (typeof msg !== "object") {
                    throw new Error("invalid message, object expected");
                }
                if (typeof msg.type !== "string") {
                    throw new Error("invalid message, missing or invalid type");
                }
                switch (msg.type) {
                    case "publish":
                        response = this._handlePublish(msg);
                        break;
                    case "subscribe":
                        response = this._handleSubscribe(msg);
                        break;
                    case "unsubscribe":
                        response = this._handleUnsubscribe(msg);
                        break;
                    case "ping":
                        response = this._handlePing(msg);
                        break;
                    case "login":
                        response = yield this._handleLogin(msg);
                        break;
                    default:
                        throw new Error(`unknown command '${msg.type}'`);
                }
            }
            catch (e) {
                const errorMessage = String(e);
                if (errorMessage) {
                    log_1.default.error(`[ ${this.name} ] error: ${errorMessage}`);
                    response = {
                        type: "error",
                        message: errorMessage,
                        seq: typeof msg === "object" ? msg.seq : undefined,
                    };
                }
            }
            if (response) {
                this._onResponseHandler(response);
            }
        });
    }
    _handlePublish(msg) {
        if (!this._authorizer.canPublish(msg.node, msg.topic)) {
            throw new Error("permission denied");
        }
        const node = this._hub.find(msg.node);
        if (!node) {
            throw new Error(`unknown node '${msg.node}'`);
        }
        if (!pubsub.isDestination(node)) {
            throw new Error(`node '${msg.node}' is not a Destination`);
        }
        const message = new message_1.default(msg.topic, msg.data, msg.headers);
        message.validate();
        node.send(message);
        if (protocol.hasSequenceNumber(msg)) {
            return {
                type: "puback",
                seq: msg.seq,
            };
        }
    }
    _handleSubscribe(msg) {
        // First check whether (un-)subscribing is allowed at all, to
        // prevent giving away info about (non-)existence of nodes.
        const authResult = this._authorizer.canSubscribe(msg.node, msg.pattern);
        if (!authResult) {
            throw new Error("permission denied");
        }
        const node = this._hub.find(msg.node);
        if (!node) {
            throw new Error(`unknown node '${msg.node}'`);
        }
        if (!pubsub.isSource(node)) {
            throw new Error(`node '${msg.node}' is not a Source`);
        }
        const id = msg.id || "default";
        let sub = this._subscriptions.get(id);
        if (!sub) {
            sub = new SubscriptionNode(this, id, this._onResponseHandler);
            this._subscriptions.set(id, sub);
        }
        // Create a matcher that filters both the subscription pattern and
        // authorization pattern(s), if needed.
        const patternMatcher = match_1.getMatcher(msg.pattern);
        let finalMatcher;
        if (typeof authResult === "function") {
            finalMatcher = (topic) => authResult(topic) && patternMatcher(topic);
        }
        else {
            // authResult is true
            finalMatcher = patternMatcher;
        }
        sub.subscribe(node, msg.pattern, finalMatcher);
        if (protocol.hasSequenceNumber(msg)) {
            return {
                type: "suback",
                seq: msg.seq,
            };
        }
    }
    _handleUnsubscribe(msg) {
        // First check whether (un-)subscribing is allowed at all, to
        // prevent giving away info about (non-)existence of nodes.
        const authResult = this._authorizer.canSubscribe(msg.node, msg.pattern);
        if (!authResult) {
            throw new Error("permission denied");
        }
        const node = this._hub.find(msg.node);
        if (!node) {
            throw new Error(`unknown node '${msg.node}'`);
        }
        if (!pubsub.isSource(node)) {
            throw new Error(`node '${msg.node}' is not a Source`);
        }
        const id = msg.id || "default";
        const sub = this._subscriptions.get(id);
        if (sub) {
            sub.unsubscribe(node, msg.pattern);
        }
        if (protocol.hasSequenceNumber(msg)) {
            return {
                type: "unsuback",
                seq: msg.seq,
            };
        }
    }
    _handlePing(msg) {
        return {
            type: "pingack",
            seq: msg.seq,
        };
    }
    _handleLogin(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._username !== undefined) {
                // Wouldn't really be a problem for now, but may be in
                // the future if e.g. different users have different quota
                // etc.
                throw new Error("already logged in");
            }
            const authenticated = yield this._hub.authenticate(msg.username, msg.password);
            if (!authenticated) {
                throw new Error("authentication failed");
            }
            this.setUsername(msg.username);
            if (protocol.hasSequenceNumber(msg)) {
                return {
                    type: "loginack",
                    seq: msg.seq,
                };
            }
        });
    }
}
exports.HubClient = HubClient;
exports.default = HubClient;
//# sourceMappingURL=hubclient.js.map
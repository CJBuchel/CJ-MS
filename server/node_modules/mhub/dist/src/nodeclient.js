"use strict";
/**
 * MHub client library for Node.JS, using einaros/ws for WebSockets.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const events = require("events");
const ws = require("ws");
const baseclient_1 = require("./baseclient");
const DEFAULT_PORT_WS = 13900;
const DEFAULT_PORT_WSS = 13901;
function noop() {
    /* no operation */
}
exports.defaultClientOptions = {
    noImplicitConnect: false,
};
class WebSocketConnection extends events.EventEmitter {
    constructor(url, options) {
        super();
        this._connected = false;
        this._socket = new ws(url, options);
        this._socket.on("error", (e) => this.emit("error", e));
        this._socket.on("open", () => {
            this.emit("open");
            this._connected = true;
        });
        this._socket.on("close", () => {
            this._connected = false;
            this.emit("close");
        });
        this._socket.on("message", (data) => {
            if (!data) {
                // Ignore empty 'lines'
                return;
            }
            const response = JSON.parse(data);
            this.emit("message", response);
        });
    }
    /**
     * Transmit data object.
     * @return Promise that resolves when transmit is accepted (i.e. not necessarily
     * arrived at other side, can be e.g. queued).
     */
    send(data) {
        return new Promise((resolve, reject) => {
            this._socket.send(JSON.stringify(data), (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(undefined);
                }
            });
        });
    }
    /**
     * Gracefully close connection, i.e. allow pending transmissions
     * to be completed.
     * @return Promise that resolves when connection is succesfully closed.
     */
    close() {
        let result;
        if (!this._connected) {
            result = Promise.resolve();
        }
        else {
            result = new Promise((resolve) => {
                this._socket.once("close", resolve);
            });
        }
        this._socket.close();
        return result;
    }
    /**
     * Forcefully close connection.
     * @return Promise that resolves when connection is succesfully closed.
     */
    terminate() {
        let result;
        if (!this._connected) {
            result = Promise.resolve();
        }
        else {
            result = new Promise((resolve) => {
                this._socket.once("close", resolve);
            });
        }
        this._socket.terminate();
        return result;
    }
}
/**
 * MHub client using server-side WebSocket.
 *
 * Allows subscribing and publishing to MHub server nodes.
 *
 * @event open() Emitted when connection was established.
 * @event close() Emitted when connection was closed.
 * @event error(e: Error) Emitted when there was a connection, server or protocol error.
 * @event message(m: Message) Emitted when message was received (due to subscription).
 */
class MClient extends baseclient_1.BaseClient {
    /**
     * Create new connection to MServer.
     * @param url Websocket URL of MServer, e.g. ws://localhost:13900
     * @param options Optional TLS settings and other options (see
     *        https://nodejs.org/dist/latest-v6.x/docs/api/tls.html#tls_tls_connect_port_host_options_callback
     *        for the TLS settings, and `MClientOptions` for other options)
     */
    constructor(url, options) {
        // Ensure options is an object and fill in defaults
        options = Object.assign(Object.assign({}, exports.defaultClientOptions), options);
        // Prefix URL with "ws://" or "wss://" if needed
        if (url.indexOf("://") < 0) {
            if (options.key || options.pfx) {
                url = "wss://" + url;
            }
            else {
                url = "ws://" + url;
            }
        }
        // Append default port if necessary
        if (!url.match(":\\d+$")) {
            const useTls = url.indexOf("wss://") === 0;
            url = url + ":" + (useTls ? DEFAULT_PORT_WSS : DEFAULT_PORT_WS);
        }
        super(() => new WebSocketConnection(url, options), options);
        this._url = url;
        if (!options.noImplicitConnect) {
            this.connect().catch(noop);
        }
    }
    /**
     * Full URL of MHub connection.
     */
    get url() {
        return this._url;
    }
}
exports.MClient = MClient;
exports.default = MClient;
//# sourceMappingURL=nodeclient.js.map
"use strict";
/**
 * MHub client library using native browser WebSocket.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const events = require("events");
const baseclient_1 = require("./baseclient");
const DEFAULT_PORT_WS = 13900;
const DEFAULT_PORT_WSS = 13901;
exports.defaultClientOptions = {};
const CLOSE_GOING_AWAY = 1001; // https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
class WebSocketConnection extends events.EventEmitter {
    constructor(url) {
        super();
        this._socket = new WebSocket(url);
        this._socket.addEventListener("error", (e) => this.emit("error", e));
        this._socket.addEventListener("open", () => {
            this.emit("open");
        });
        this._socket.addEventListener("close", () => {
            this.emit("close");
        });
        this._socket.addEventListener("message", (event) => {
            if (!event.data) {
                // Ignore empty 'lines'
                return;
            }
            const response = JSON.parse(event.data);
            this.emit("message", response);
        });
    }
    /**
     * Transmit data object.
     * @return Promise that resolves when transmit is accepted (i.e. not necessarily
     * arrived at other side, can be e.g. queued).
     */
    send(data) {
        return new Promise((resolve) => {
            this._socket.send(JSON.stringify(data));
            resolve(undefined);
        });
    }
    /**
     * Gracefully close connection, i.e. allow pending transmissions
     * to be completed.
     * @return Promise that resolves when connection is succesfully closed.
     */
    close(code) {
        let result;
        if (!this._connected) {
            result = Promise.resolve();
        }
        else {
            result = new Promise((resolve) => {
                this._socket.addEventListener("close", () => resolve(undefined));
            });
        }
        this._socket.close(code);
        return result;
    }
    /**
     * Forcefully close connection.
     * @return Promise that resolves when connection is succesfully closed.
     */
    terminate() {
        return this.close(CLOSE_GOING_AWAY);
    }
    get _connected() {
        return this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN;
    }
}
/**
 * MHub client using server-side WebSocket.
 *
 * Allows subscribing and publishing to MHub server nodes.
 *
 * @event open() Emitted when connection was established.
 * @event close() Emitted when connection was closed.
 * @event error(e: Error) Emitted when there was a connection, server or protocol error.
 * @event message(m: Message) Emitted when message was received (due to subscription).
 */
class MClient extends baseclient_1.BaseClient {
    /**
     * Create new connection to MServer.
     * @param url Websocket URL of MServer, e.g. ws://localhost:13900
     * @param options Optional options, see `MClientOptions`.
     */
    constructor(url, options) {
        // Ensure options is an object and fill in defaults
        options = Object.assign(Object.assign({}, exports.defaultClientOptions), options);
        // Prefix URL with "ws://" if needed
        if (url.indexOf("://") < 0) {
            url = "ws://" + url;
        }
        // Append default port if necessary
        if (!url.match(":\\d+$")) {
            const useTls = url.indexOf("wss://") === 0;
            url = url + ":" + (useTls ? DEFAULT_PORT_WSS : DEFAULT_PORT_WS);
        }
        super(() => new WebSocketConnection(url), options);
        this._url = url;
    }
    /**
     * Full URL of MHub connection.
     */
    get url() {
        return this._url;
    }
}
exports.MClient = MClient;
exports.default = MClient;
//# sourceMappingURL=browserclient.js.map
"use strict";
/**
 * Commandline tool for determining latency.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const yargs = require("yargs");
const nodeclient_1 = require("./nodeclient");
const tlsHelpers_1 = require("./tlsHelpers");
const usage = [
    "Sends a message to the given node, waits for an answer, then sends the next etc.",
    "Prints the round-trip time for each message.",
    "",
    "Make sure you have the `test` node enabled in mhub-server, or provide your own",
    "routing to respond with `ping:response` to each `ping:request`",
].join("\n");
function die(fmt, ...args) {
    // tslint:disable-next-line:no-console
    console.error(fmt, ...args);
    return process.exit(1);
}
const argv = yargs
    .usage(usage)
    .help("help")
    // tslint:disable-next-line:no-require-imports
    .version()
    .alias("v", "version")
    .option("socket", {
    type: "string",
    alias: "s",
    description: "WebSocket to connect to",
    default: "localhost:13900",
})
    .option("node", {
    type: "string",
    alias: "n",
    description: "Node to subscribe/publish to",
    default: "ping",
})
    .option("data", {
    type: "string",
    alias: "d",
    description: "Optional message data as JSON object, e.g. '\"a string\"' or '{ \"foo\": \"bar\" }'",
})
    .option("headers", {
    type: "string",
    alias: "h",
    description: "Optional message headers as JSON object, e.g. '{ \"my-header\": \"foo\" }'",
})
    .option("count", {
    type: "number",
    alias: "c",
    description: "Number of pings to send",
    default: 10,
})
    .option("insecure", {
    type: "boolean",
    description: "Disable server certificate validation, useful for testing using self-signed certificates",
})
    .option("key", {
    type: "string",
    description: "Filename of TLS private key (in PEM format)",
})
    .option("cert", {
    type: "string",
    description: "Filename of TLS certificate (in PEM format)",
})
    .option("ca", {
    type: "string",
    description: "Filename of TLS certificate authority (in PEM format)",
})
    .option("passphrase", {
    type: "string",
    description: "Passphrase for private key",
})
    .option("pfx", {
    type: "string",
    description: "Filename of TLS private key, certificate and CA certificates " +
        "(in PFX or PKCS12 format). Mutually exclusive with --key, --cert and --ca.",
})
    .option("crl", {
    type: "string",
    description: "Filename of certificate revocation list (in PEM format)",
})
    .option("ciphers", {
    type: "string",
    description: "List of ciphers to use or exclude, separated by :",
})
    .option("username", {
    type: "string",
    alias: "U",
    description: "Username",
})
    .option("password", {
    type: "string",
    alias: "P",
    description: "Password. Note: sent in plain-text, so only use on secure connection. " +
        "Also note it may appear in e.g. `ps` output.",
})
    .strict()
    .argv;
function createClient() {
    const tlsOptions = {};
    tlsOptions.pfx = argv.pfx;
    tlsOptions.key = argv.key;
    tlsOptions.passphrase = argv.passphrase;
    tlsOptions.cert = argv.cert;
    tlsOptions.ca = argv.ca;
    tlsOptions.crl = argv.crl;
    tlsOptions.ciphers = argv.ciphers;
    tlsOptions.rejectUnauthorized = !argv.insecure;
    tlsHelpers_1.replaceKeyFiles(tlsOptions, process.cwd());
    const client = new nodeclient_1.default(argv.socket, tlsOptions);
    client.on("error", (e) => {
        die("Client error:", e);
    });
    return client.connect().then(() => {
        if (argv.username) {
            return client.login(argv.username, argv.password || "");
        }
    }).then(() => client);
}
let data;
try {
    data = argv.data && JSON.parse(argv.data);
}
catch (e) {
    // tslint:disable-next-line:no-console
    console.error("Error parsing message data as JSON: " + e.message);
    die("Hint: if you're passing a string, make sure to put double-quotes around it, " +
        "and escape these quotes for your shell with single-quotes, e.g.: '\"my string\"'");
}
let headers;
try {
    headers = argv.headers && JSON.parse(argv.headers);
}
catch (e) {
    die("Error parsing message headers as JSON: " + e.message);
}
const pingCount = argv.count;
/**
 * High-res timestamp in milliseconds.
 */
function now() {
    const hrTime = process.hrtime();
    return hrTime[0] * 1000000000 + hrTime[1] / 1000000;
}
createClient().then((client) => __awaiter(void 0, void 0, void 0, function* () {
    function ping() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = new Promise(resolve => {
                client.once("message", (msg) => {
                    const reply = JSON.stringify(msg.data);
                    if (argv.data === reply) {
                        resolve();
                    }
                });
            });
            const request = client.publish(argv.node, "ping:request", data, headers);
            let timeoutTimer;
            const timeout = new Promise((_, reject) => {
                timeoutTimer = setTimeout(() => reject(new Error("timeout")), 1000);
            });
            try {
                yield Promise.race([Promise.all([request, response]), timeout]);
            }
            finally {
                clearTimeout(timeoutTimer);
            }
        });
    }
    client.subscribe(argv.node, "ping:response");
    for (let i = 0; i < pingCount; i++) {
        const start = now();
        try {
            yield ping();
            console.log(`pong ${i}: ${(now() - start).toFixed(3)}ms`); // tslint:disable-line:no-console
        }
        catch (err) {
            console.warn(err.message || `${err}`); // tslint:disable-line:no-console
        }
    }
    return client.close();
})).catch(die);
//# sourceMappingURL=mhub-ping.js.map
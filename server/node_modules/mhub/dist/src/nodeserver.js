"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const https = require("https");
const net = require("net");
const ws = require("ws");
const authenticator_1 = require("./authenticator");
const hub_1 = require("./hub");
const tcpconnection_1 = require("./transports/tcpconnection");
const wsconnection_1 = require("./transports/wsconnection");
const storage = require("./storage");
const DEFAULT_PORT_WS = 13900;
const DEFAULT_PORT_WSS = 13901;
const DEFAULT_PORT_TCP = 13902;
// Register known node types
const consoleDestination_1 = require("./nodes/consoleDestination");
const exchange_1 = require("./nodes/exchange");
const headerStore_1 = require("./nodes/headerStore");
const pingResponder_1 = require("./nodes/pingResponder");
const queue_1 = require("./nodes/queue");
const testSource_1 = require("./nodes/testSource");
const topicStore_1 = require("./nodes/topicStore");
const nodeClasses = [
    consoleDestination_1.default,
    exchange_1.default,
    pingResponder_1.default,
    queue_1.default,
    testSource_1.default,
    topicStore_1.default,
    headerStore_1.default,
];
const nodeClassMap = {};
nodeClasses.forEach((c) => {
    nodeClassMap[c.name] = c;
});
// For backward compatibility
nodeClassMap.TopicQueue = topicStore_1.default;
nodeClassMap.TopicState = topicStore_1.default;
class MServer {
    constructor(normalizedConfig, hub) {
        this.logger = undefined;
        this.connectionId = 0;
        this.plainAuth = new authenticator_1.PlainAuthenticator();
        this.hub = hub || new hub_1.default(this.plainAuth);
        this.normalizedConfig = normalizedConfig;
        this.setUsers(normalizedConfig);
        this.setPermissions(normalizedConfig);
        this.instantiateNodes(normalizedConfig);
        this.setupBindings(normalizedConfig);
        this.setStorage(normalizedConfig);
    }
    init() {
        return this.hub.init().then(() => {
            return this.startTransports(this.hub, this.normalizedConfig);
        }).catch((err) => {
            throw new Error(`Failed to initialize:` + JSON.stringify(err, null, 2));
        });
    }
    setLogger(logger) {
        this.logger = logger;
    }
    log(fmt, ...args) {
        if (this.logger) {
            this.logger.info(fmt, ...args);
        }
    }
    setUsers({ users }) {
        const usernames = Object.keys(users);
        usernames.forEach((username) => {
            this.plainAuth.setUser(username, users[username]);
        });
    }
    // Set up user permissions
    setPermissions({ rights }) {
        try {
            this.hub.setRights(rights);
        }
        catch (err) {
            throw new Error("Invalid configuration: `rights` property: " + err.message);
        }
    }
    // Instantiate nodes from config file
    instantiateNodes({ nodes }) {
        Object.keys(nodes).forEach((nodeName) => {
            let def = nodes[nodeName];
            if (typeof def === "string") {
                def = {
                    type: def,
                };
            }
            const typeName = def.type;
            const nodeConstructor = nodeClassMap[typeName];
            if (!nodeConstructor) {
                throw new Error(`Unknown node type '${typeName}' for node '${nodeName}'`);
            }
            const node = new nodeConstructor(nodeName, def.options);
            this.hub.add(node);
        });
    }
    // Setup bindings between nodes
    setupBindings({ bindings }) {
        bindings.forEach((binding, index) => {
            const from = this.hub.findSource(binding.from);
            if (!from) {
                throw new Error(`Unknown Source node '${binding.from}' in \`binding[${index}].from\``);
            }
            const to = this.hub.findDestination(binding.to);
            if (!to) {
                throw new Error(`Unknown Destination node '${binding.to}' in \`binding[${index}].to\``);
            }
            from.bind(to, binding.pattern);
        });
    }
    setStorage({ storage: storageRoot }) {
        if (typeof storageRoot !== "string") {
            throw new Error(`Invalid storage root, string expected`);
        }
        const simpleStorage = new storage.ThrottledStorage(new storage.SimpleFileStorage(storageRoot));
        this.hub.setStorage(simpleStorage);
    }
    // Initialize and start server
    startWebSocketServer(hub, options) {
        return new Promise((resolve, reject) => {
            options = Object.assign({}, options); // clone
            let server;
            const useTls = !!(options.key || options.pfx);
            options.port = options.port || (useTls ? DEFAULT_PORT_WSS : DEFAULT_PORT_WS);
            if (useTls) {
                server = https.createServer(options);
            }
            else {
                server = http.createServer();
            }
            const wss = new ws.Server({ server: server, path: "/" });
            wss.on("connection", (conn) => {
                // tslint:disable-next-line:no-unused-expression
                new wsconnection_1.default(hub, conn, "websocket" + this.connectionId++);
            });
            wss.on("error", (e) => {
                reject(e);
            });
            server.listen(options.port, () => {
                this.log(`WebSocket Server started on port ${options.port}${useTls ? " (TLS)" : ""}`);
                resolve(undefined);
            });
        });
    }
    startTcpServer(hub, options) {
        return new Promise((resolve, reject) => {
            options = Object.assign({}, options); // clone
            options.port = options.port || DEFAULT_PORT_TCP;
            const server = net.createServer((socket) => {
                // tslint:disable-next-line:no-unused-expression
                new tcpconnection_1.default(hub, socket, "tcp" + this.connectionId++);
            });
            server.on("error", (e) => {
                reject(e);
            });
            server.listen({
                port: options.port,
                host: options.host,
                backlog: options.backlog,
            }, () => {
                this.log("TCP Server started on port " + options.port);
                resolve(undefined);
            });
        });
    }
    startTransports(hub, config) {
        const serverOptions = Array.isArray(config.listen) ? config.listen : [config.listen];
        return Promise.all(serverOptions.map((options) => {
            switch (options.type) {
                case "websocket":
                    return this.startWebSocketServer(hub, options);
                case "tcp":
                    return this.startTcpServer(hub, options);
                default:
                    throw new Error(`unsupported transport '${options.type}'`);
            }
        })).then(() => undefined);
    }
}
exports.MServer = MServer;
//# sourceMappingURL=nodeserver.js.map
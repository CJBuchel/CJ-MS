"use strict";
/**
 * Simple file storage.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const mkdirp_1 = require("mkdirp");
const path = require("path");
const promise_1 = require("./promise");
class SimpleFileStorage {
    constructor(rootDir) {
        this._rootDir = rootDir;
        mkdirp_1.sync(this._rootDir);
    }
    save(key, value) {
        // First save it to a temp file, then move that over the original
        // to make it an atomic replace
        const realFile = this._getFilename(key);
        const tmpFile = realFile + ".tmp";
        return new Promise((resolve, reject) => {
            const data = JSON.stringify(value);
            fs.writeFile(tmpFile, data + (data ? "\n" : ""), "utf8", (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(undefined);
                }
            });
        }).then(() => {
            return new Promise((resolve, reject) => {
                fs.rename(tmpFile, realFile, (err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(undefined);
                    }
                });
            });
        });
    }
    load(key) {
        return new Promise((resolve, reject) => {
            fs.readFile(this._getFilename(key), "utf8", (err, data) => {
                if (err) {
                    if (err.code === "ENOENT") {
                        // Return `undefined` when key does not exist (yet)
                        resolve(undefined);
                    }
                    reject(err);
                }
                else {
                    try {
                        resolve(JSON.parse(data));
                    }
                    catch (e) {
                        reject(e);
                    }
                }
            });
        });
    }
    _getFilename(key) {
        return path.resolve(this._rootDir, key + ".json");
    }
}
exports.SimpleFileStorage = SimpleFileStorage;
class ThrottledStorage {
    constructor(storage, throttleDelay = 100) {
        this._saveQueue = Object.create(null); // tslint:disable-line:no-null-keyword
        this._slave = storage;
        this._delay = throttleDelay;
    }
    save(key, value) {
        // TODO make sure to flush on exit!
        const doSave = () => {
            const latestItem = this._saveQueue[key];
            const lastValue = latestItem.lastValue;
            // Mark existing record as 'in-progress' by unsetting
            // the value. If another save is requested, it will still
            // be chained after the current write.
            latestItem.lastValue = undefined;
            if (lastValue !== undefined) {
                return this._slave.save(key, lastValue);
            }
        };
        // Get or create pending action record for this key
        let item = this._saveQueue[key];
        if (!item) {
            item = {
                lastValue: undefined,
                promise: Promise.resolve(),
            };
            this._saveQueue[key] = item;
        }
        // If no save action is currently scheduled (either because there
        // was none, or because an existing save is currently underway)
        // schedule a new one
        if (item.lastValue === undefined) {
            item.lastValue = value;
            item.promise = item.promise.then(() => promise_1.delay(this._delay)).then(doSave).finally(() => {
                // If there are no pending saves anymore, we can safely remove
                // the record for this key, otherwise keep it until the scheduled
                // save is done with it
                if (item.lastValue === undefined) {
                    delete this._saveQueue[key];
                }
            });
        }
        return item.promise;
    }
    load(key) {
        return this._slave.load(key);
    }
}
exports.ThrottledStorage = ThrottledStorage;
//# sourceMappingURL=storage.js.map
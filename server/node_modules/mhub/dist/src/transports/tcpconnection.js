"use strict";
/**
 * Connect TCP socket to an MServer hub.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const hubclient_1 = require("../hubclient");
const log_1 = require("../log");
class TcpConnection {
    constructor(hub, socket, name) {
        this._buffer = "";
        this._socket = socket;
        this._name = name;
        this._client = new hubclient_1.default(hub, this._name);
        this._client.on("response", this._handleClientResponse.bind(this));
        socket.setEncoding("utf8");
        socket.on("close", this._handleSocketClose.bind(this));
        socket.on("error", this._handleSocketError.bind(this));
        socket.on("data", this._handleSocketData.bind(this));
        log_1.default.info("[ %s ] connected", this._name);
    }
    _handleClientResponse(response) {
        this._socket.write(JSON.stringify(response) + "\n");
    }
    _handleSocketClose() {
        this._client.close();
        log_1.default.info(`[ ${this._name} ] disconnected`);
    }
    _handleSocketError(e) {
        log_1.default.error(`[ ${this._name} ] socket error ${e}`);
        this._socket.destroy(); // will cause close event, which causes client close
    }
    _handleProtocolError(e) {
        log_1.default.error(`[ ${this._name} ] protocol error ${e}`);
        this._handleClientResponse({
            type: "error",
            message: `protocol error: ${e}`,
        });
        this._socket.destroy();
    }
    _handleSocketData(chunk) {
        // Add new chunk to buffer, start looking for lines
        // in buffer
        this._buffer += chunk;
        while (this._buffer.length > 0) {
            const p = this._buffer.indexOf("\n");
            if (p < 0) {
                // Incomplete line, keep it in buffer for now
                break;
            }
            // Strip first line from buffer
            const line = this._buffer.substr(0, p).trim();
            this._buffer = this._buffer.substr(p + 1);
            if (!line) {
                // Ignore empty lines
                continue;
            }
            // Process line
            log_1.default.debug(`[ ${this._name} ] command ${line}`);
            try {
                const cmd = JSON.parse(line);
                this._client.processCommand(cmd)
                    .catch((e) => this._handleProtocolError(e));
            }
            catch (e) {
                this._handleProtocolError(e);
                break;
            }
        }
    }
}
exports.TcpConnection = TcpConnection;
exports.default = TcpConnection;
//# sourceMappingURL=tcpconnection.js.map